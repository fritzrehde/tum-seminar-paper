\documentclass[sigplan,11pt,nonacm]{acmart}
\settopmatter{printfolios}

\usepackage{booktabs} % For formal tables
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{hyphenat}
\usepackage{todonotes}
\usepackage[babel]{csquotes}
\usepackage{listings}
\lstset{frame=tb,
  language=Rust,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\begin{document}
\title{Ownership types in theory and practice (in Rust)}
\author{Fritz Rehde}
\affiliation{%
  \institution{Technical University of Munich}
}
\email{fritz.rehde@tum.de}

\begin{abstract}
% Abstract: Brief summary of area, problem, approach, key result

% why do we need ownership types, what do they do?

Object aliasing is the concept of accessing the same memory through different symbolic names in object-oriented programming languages.
Many progamming bugs are created through unintentional aliases, which are hard to detect and can lead to unexpected side-effects.
Ownership types are one solution that attempt to prevent many alias-related bugs.
The premise of ownership types is that not only the fields of an object are protected from external access, but also all objects stored in those fields.
This is done by allowing objects to take ownership of other objects.
% TODO: add citation\cite{ownership-types-survey}

% This paper depicts the different kinds of ownership types and explains how the modern programming language Rust uses ownership types to garantee memory safety.
This paper depicts the different kinds of ownership types and explains how the modern programming language Rust uses ownership types.

\end{abstract}

\keywords{Ownership, Type, Safety, Rust}

\maketitle

\section{Introduction}
\label{sec:introduction}
% Introduction: introduce area, problem, approach, key results, contributions, outline

% TODO: write something


\section{Background}
\label{sec:background}
% Background: if needed, describe prerequisites

One of the main goals of ownership types is to improve memory safety.
Understanding memory-related bugs will, therefore, help in understanding why ownership types are useful.

\subsection{Memory Safety}

% source: Definition of memory safety\cite{memory1}.
% source: Why memory safery is important\cite{nsa-memory-safety}.

Memory safety is defined as ...


\subsection{State of the art}

% - when/in which language first introduced?
% - why slow adoption?

Potential solutions to the aliasing problem include banning aliases altogether, clearly advertising aliases or managing and controlling its effects\cite{ownership-types-survey}.
Many different flavours of ownership types have been explored.
In this paper, state of the art implementations of the ownership types concept such as owners-as-dominators, owners-as-modifiers and owners-as-ombudsmen will be explored further.
These approaches differ in what kind of, if any, aliases they allow.
\cite{ownership-types-survey}


% Main part (approach, evaluation, discussion, etc.)

\section{Ownership types in theory}

% TODO: second source to provide more detail of each owners-as-...
% TODO: find more varied words to classify these approaches as: principle, approach, model
% TODO: maybe add numbered list (like in source material) for the rules like in the Rust section

\subsection{Domain specific terms}

In the following, some terms that are commonly used throughout this paper are explained.
The core concept of ownership types is that objects can be \emph{owners} of other objects.
Given objects \emph{a} and \emph{b}, \emph{a} is \emph{inside} \emph{b} if \emph{a} is the same object as \emph{b} or \emph{a} is \emph{owned} by \emph{b}, transitively.
The \emph{outside} relation is the converse of the \emph{inside} relation.

In most ownership type variants, the heap is divided into different regions called ownership contexts.
Each object has one single ownership context, which is the set of all objects it owns.
Objects that are in the same ownership context are called \emph{siblings} or \emph{peers}.
\cite{ownership-types-survey}


\subsection{Owners-as-dominators}

One such flavour is the owners-as-dominators\cite{ownership-types-survey} invariant, where the heap is structured as a tree with each object being inside its owner.
External access is therefore only possible through the owner.
The rules that must be fulfilled for \emph{a} to validly reference \emph{b} are that either \emph{a} is owned by \emph{b}, \emph{a} and \emph{b} are siblings or \emph{b} is outside \emph{a}.
% TODO: more detail

The owners-as-dominators principle provides a simple, clear and strong guarantee, but makes programming more difficult by not allowing common idioms through aliasing.
\cite{ownership-types-survey}


\subsection{Owners-as-modifiers}

Another kind is the owners-as-modifiers model, which is a weaker form of owners-as-dominators that additionally allows read-only references.
A read-only reference can only be used to read files and call pure methods, which may not modify any existing objects.
In essence, aliasing is unrestricted, but only the owner of an object can modify it.
% TODO: unclear sentence structure
Owners-as-modifiers extend the rules specified for owners-as-dominators.
For \emph{a} to validly reference \emph{b} through reference \emph{r}, owners-as-modifiers follows the same rules as owners-as-dominators.
The only addition is that \emph{r} can also be a valid reference if it is a read-only reference and only pure methods are being called on it.
% TODO: more detail

The owners-as-modifiers principle expands the programming possibilities of the owners-as-modifiers principle and fulfills the requirements needed for the verification of object-oriented programs.

\cite{ownership-types-survey}


\subsection{Owners-as-ombudsmen}

% TODO: definition of ombudsmen for context
A last flavour of ownership types is the owners-as-ombudsmen approach, which allows idioms that do not adhere to the strong topological structure of a tree structure to be implemented.
% TODO: examples
This is achieved by allowing multiple objects to define a shared aggregate owner.
% TODO: what is aggregate owner
Extending the rules stated for owners-as-dominators, \emph{a} can also validly reference \emph{b} if \emph{a} is owned by aggregate owner \emph{b}.

\cite{ownership-types-survey}


% \subsection{Application of Ownership Types}

% TODO: chapter 6 of ownership-types-survey

% TODO: inconsistent use of method and function
\section{Implementation in Rust}

There are two major requirements that a memory allocation system must fulfill:
At runtime, memory can be requested from the memory allocator and there exists a mechanism for memory to be freed by the memory allocator.

The first requirement is trivial.

% TODO: find source for both garbage collection and manual freeing
One possible implementation of the second requirement is using a garbage collector, which keeps track of and cleans up memory that is no longer used.
% TODO: find source for GC disadvantages
This, however, has a runtime performance overhead and can lead to a non-deterministic cleanup of resources.

% TODO: find source for manual free disadvantages
Another more traditional solution is requiring memory to be freed explicitly.
This is a notorious source of bugs.
If memory is never freed because it was forgotten, memory is wasted.
If it is freed multiple times or accessed again after having been freed, it will result in undefined behaviour.

The ideal solution pairs one \emph{allocate} with exactly one \emph{free}.
Rust uses neither a garbage collector nor requires memory to be freed manually.
Instead, the concept of ownership is leveraged to determine when to free memory.

The Rust book \cite{rust-book} defines ownership as a set of rules that govern how it manages memory.
The compiler checks whether these rules are adhered to, and does not compile the program if they are violated.
The ownership rules in Rust are as follows:
\begin{enumerate}
  \item Each value in Rust has an owner.
  \item There can only be one owner at a time.
  \item When the owner goes out of scope, the value will be \emph{dropped}.
\end{enumerate}
% Rust automatically calls the function \emph{drop} when a variable goes out of scope, which frees the memory of the value that is owned by that variable.
% TODO: is a variable really an owner of a value? Possibly change term variable
The scope of a value is the range within a program in which it is valid.
Rust automatically calls the function \emph{drop}, which frees the associated memory, when a variable goes out of scope.

The following describes how the concept of ownership is implemented in Rust.

% TODO: wording of value and types used interchangedly here, maybe incorrect
% TODO: maybe add defintion of ownership transfer if not obvious
% TODO: go into detail on how heap types are stored on heap. some constant fields are actually stored on stack (string: pointer, size, capacity)
\subsection{Transferring ownership}

First, one must differentiate between values that are stored on the stack and those stored on the heap.
In Rust, primitive data types (e.g. signed 32 bit integers \emph{i32}) are stored on the stack, since their sizes are small and known at compile time.
In contrast, values are stored on the heap if their size is dynamic and, therefore, unknown at compile time.
The ownership concepts in Rust mostly apply to values stored on the heap.
% Thus, the behaviour of values stored on the stack will be explained later.

\paragraph{Heap-based variables}

% TODO: source
In addition to the memory safety that ownership types provide, ownership transfers can also reduce redundant copy operations.
Since heap-based values could be arbitrarily large at runtime, copying the whole value instead of transferring ownership could be very inefficient.
There are several different scenarios in which ownership is transferred.

In the simplest scenario, ownership is transferred from the variable \emph{a} to the variable \emph{b} when \emph{b} is assigned to \emph{a}.
% TODO: footnote that main class etc. have been omitted for sake of simplicity
\begin{lstlisting}
let a = HeapBasedType::default();
let b = a;
\end{lstlisting}
In Rust terminology, \emph{a} is \emph{moved} into \emph{b}.
After the move, \emph{a} is no longer valid and \emph{b} is the new owner of the value.

Heap-based values will always be generated by a function at runtime.
Therefore, one can generalize the above scenario to ownership being transferred from the variable \emph{a} to the variable \emph{b} when \emph{b} is assigned to the return value \emph{a} of \emph{foo}.
\begin{lstlisting}
fn main() {
  let b = foo();
}
fn foo() {
  let a = HeapBasedType::default();
  a
}
\end{lstlisting}

Lastly, ownership is transferred from the variable \emph{a} to the variable \emph{b} when \emph{a} is passed to function \emph{foo} which takes a parameter \emph{b}.
\begin{lstlisting}
fn main() {
  let a = HeapBasedType::default();
  foo(a);
}
fn foo(b: HeapBasedType) {
  // do something with b
}
\end{lstlisting}
In \emph{foo}, \emph{b} is the owner of the value until it is \emph{dropped} at the end of the function.
Accessing the previous owner of a value after the ownership of that value has been transferred elsewhere will lead to a compile-time error.
In this case, trying to access \emph{a} after line 3 would not compile, as \emph{a} is no longer the owner of the value.

The heap-allocated \emph{String} type in Rust provides a good example that demonstrates ownership transfer of heap-based values.
\begin{lstlisting}
let x: String = String::from("hello world");
let y: String = x;
println!("x: {}, y: {}", x, y);
\end{lstlisting}
After \emph{x} is moved into \emph{y} in line 2, \emph{x} is no longer valid.
Therefore, Rust prevents you from accessing the invalid \emph{x} in the third line, and the program will not compile.


% TODO: explain what Rust traits are
\paragraph{Stack-based values}

In contrast to heap-based values, the size of stack-based values is known at compile time and usually small.
Therefore, stack-based values in Rust are \emph{copied} instead of \emph{moved}.
% TODO: reformulate
Internally, this works because primitive types are annotated with and implement the \emph{Copy} trait.

% The two main representations of strings in Rust provide a good example.
Besides the heap-allocated \emph{String} type, Rust also supports string literals \emph{\&str}, which are stored on the stack.

The following piece of code, which is similar to the code from above but replaces the \emph{String} type with string literals, demonstrates how stack-based string literals are \emph{copied} instead of \emph{moved} into other variables in Rust.
\begin{lstlisting}
let x: &str = "hello world";
let y: &str = x;
println!("x: {}, y: {}", x, y);
\end{lstlisting}
The value of \emph{x} is copied into \emph{y}, after which both variables are still valid.
Therefore, the program compiles and "x: hello world, y: hello world" is printed to stdout.
\cite{rust-book}


\subsection{The Clone trait}

By default and by design, Rust will never automatically create deep copies of data stored on the heap.
To do so, one must explicitly call the \emph{clone} method on an object.

The following adjustement to the code snippet from above creates a deep copy of \emph{x} and compiles successfully.
\begin{lstlisting}
let x: String = String::from("hello world");
let y: String = x.clone();
println!("x: {}, y: {}", x, y);
\end{lstlisting}

% The ownership of a value is not only transferred during the assignment to another variable, but also when it is passed to a function as a parameter and when it is returned from a function.

\cite{rust-book}


\subsection{Immutability}

By default, all values and references in Rust are immutable.
% TODO: source
An object is defined as immutable if its state cannot be modified after its creation.
In Rust, mutable values and references must be explicitly created using the \emph{mut} keyword.

For example, a string literal can be appended to a mutable String.
\begin{lstlisting}
let mut s = String::from("hello");
s.push_str("hello");
\end{lstlisting}


\subsection{References and borrowing}

% TODO: latex link to owners-as-... section
As pointed out in the owners-as-dominators section, many common programming idioms require some form of aliasing or referencing.
In Rust, a \emph{reference} is an address that points to a value that is owned by another variable.
Unlike traditional \emph{pointers} used in other low-level programming languages, a reference is guaranteed to point to a valid value.
In Rust terminology, creating a reference is called \emph{borrowing}.
A reference does not own the value it points to.
Therefore, only the reference itself, not the value which it has borrowed, is dropped at the end of the reference's scope.
Borrowing is useful for performing an operation on a value without taking ownership of it.

Rust supports creating both immutable and mutable references.

\paragraph{Immutable references}

Immutable references can be seen as read-only references and are acquired using the \emph{\&} operator.
The value that immutable references refer to may not be modified, otherwise program will not compile.

\begin{lstlisting}
fn main() {
  let s = String::from("hello");
  let s1 = &s;
  let s2 = &s;
  print\_str(s1);
  print\_str(s2);
}
fn print\_str(s: &String) {
  println!("printed from a reference: {}", s);
}
\end{lstlisting}

As long as the value \emph{s} is not modified in the \emph{print\_str} function, the program will compile.
Furthermore, an unlimited amount of immutable references to the same value can be created, as long as there exists no mutable reference to the value.


% TODO: multiple &mut are technically only illegal if used
\paragraph{Mutable references}

Rust also supports mutable references, which are created with the \emph{&mut} keyword and allow the borrowed value to be modified.
For obvious reasons, the borrowed value also has to be mutable.

\begin{lstlisting}
fn main() {
  let mut s = String::from("hello");
  modify\_str(&mut s);
}
fn modify\_str(s: &mut String) {
  s.push\_str(" world");
}
\end{lstlisting}

However, there is only allowed to be multiple mutable references to the same value at a time.
At any given time, there may only exist one mutable reference to a value.
Any further references during that time, whether immutable or mutable, are not allowed.
However, Rust does not allow multiple mutable references to the same value.
However, Rust only allows one mutable reference to exist and 

\subsection{Borrowing}

\subsection{Slice type}

\subsection{Lifetimes}


\section{Practical examples using Rust}
% - show common Rust ownership errors
% - Protection against memory vulnerabilitie examples
% - reference: \cite{rust-by-example}


\section{Alternatives}
% - comparison to alternative type systems without ownership (C/C++: none at all, Java: garbage collection)
% - choose non-ownership programming language e.g. C++20
% - compare code examples
% - compile time differences between Rust and non-ownership lang
% - runtime differences between Rust and non-ownership lang


\section{Related work}
\label{sec:relatedwork}
% (In a paper: Related Work – might come before main part)


\section{Summary \& Outlook}
\label{sec:summary}



\bibliographystyle{ACM-Reference-Format}
\bibliography{paper} % read paper.bib file

\end{document}
