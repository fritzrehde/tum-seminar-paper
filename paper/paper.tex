\documentclass[sigplan,11pt,nonacm]{acmart}
\settopmatter{printfolios}

\usepackage{booktabs} % For formal tables
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{hyphenat}
\usepackage{todonotes}
\usepackage[babel]{csquotes}
\usepackage{listings}
\lstset{frame=tb,
  % language=Rust,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numbersep=5pt,
  xleftmargin=\parindent,
  numberstyle=\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2
}

\begin{document}
\title{Ownership types in theory and practice (in Rust)}
\author{Fritz Rehde}
\affiliation{%
  \institution{Technical University of Munich}
  \country{Germany}
}
\email{fritz.rehde@tum.de}

\begin{abstract}
% Abstract: Brief summary of area, problem, approach, key result

Object aliasing is the concept of accessing the same memory through different symbolic names in object-oriented programming languages.
Many programming bugs are created through unintentional aliases, which are hard to detect and can lead to unexpected side effects.
Ownership types are one solution that attempts to prevent many alias-related bugs.
The premise of ownership types is that not only the fields of an object are protected from external access, but also all objects stored in those fields.
This is done by allowing objects to take ownership of other objects.

This paper depicts the different kinds of ownership types and explains how the modern programming language Rust uses ownership types.

\end{abstract}

\keywords{Ownership, Type, Safety, Rust}

\maketitle

\section{Introduction}
\label{sec:introduction}
% Introduction: introduce area, problem, approach, key results, contributions, outline

One of the main goals of ownership types is to improve memory safety.
Understanding memory-related bugs will, therefore, help in understanding why ownership types are useful.


\subsection{Memory Safety}
\label{sec:memory-safety}

% TODO: define memory safety
% Memory safety refers to the state of a program where memory pointers or references always refer to valid memory.

The tech giants Google \cite{google-memory-safety} and Microsoft \cite{microsoft-memory-safety} have both revealed that around 70 percent of their vulnerabilities were the result of memory safety issues.
The importance of memory safety is further underlined by the fact that the National Security Agency of the United States of America has published a Cybersecurity Information Sheet \cite{nsa-memory-safety} on the topic, the contents of which are described in the following section.

There are a variety of potential occurrences of memory management issues.
Examples include \emph{buffer overflows}, where data is accessed outside the bounds of an array, \emph{memory leaks}, where the programmer forgets to free memory that has been allocated, causing the program to, eventually, run out of memory, \emph{Use-After-Free}, where memory is accessed after it has been freed,\emph{Double-Free}, where memory is freed again after it had already been freed before, and the use of uninitialized memory.
These issues can not only enable potential malicious exploits, they can also result in incorrect program results, the decrease of a program's performance or seemingly random program crashes.

Commonly used programming languages, such as C and C++, provide a lot of freedom and flexibility in memory management, but this comes at the cost of heavily relying on the programmer to perform the needed checks on memory references.
Furthermore, the developers must perform rigorous testing to ensure the software handles surprising conditions.
Even though software analysis tools can detect many instances of memory management issues, the NSA recommends the use of inherently memory-safe languages.

\paragraph{Example}

Ralf Jung \cite{understanding-evolving-rust} provides the following typical example of how ownership types can prevent a memory safety issue.

First, we will explore how a memory safety problem is created in the following C++ code snippet that does not use the ownership concept.

\begin{lstlisting}
std::vector<int> v { 10, 11 };
int *vptr = &v[1]; // points *into* v
v.push_back(12);
std::cout << *vptr; // bug (use-after-free)
\end{lstlisting}

We initialize a vector \emph{v} that contains two integers stored in a buffer in memory.
Next, we create a pointer \emph{vptr} that points into this buffer, specifically to the place where the second element (with current value 11) is stored.
Now, both \emph{v} and \emph{vptr} point to (overlapping parts of) the same buffer.
% TODO: change wording from source
We say that the two pointers are aliasing.
Then, we push a new element to the end of \emph{v}.
If the vector's capacity were large enough, the new element would be appended to the buffer.
However, we will assume there is no more space for an additional element, so a new buffer is allocated, and all the existing elements are moved over.
This case is interesting because \emph{vptr} still points to the old buffer!
In other words, adding a new element to \emph{v} has turned \emph{vptr} into a dangling pointer.
Therefore, trying to access the value the dangling pointer \emph{vptr} points to will cause a use-after-free bug.
% More generally, we can observe that an action through a pointer (\emph{v}) will also affect all of its aliases (\emph{vptr}).
The main problem here is that such memory issues cannot be detected at compile time.

% TODO: add graph from paper to visualize

Now, we will demonstrate how ownership types in Rust allow the compiler to detect such a use-after-free bug.
Consider the following Rust translation of our C++ example:

\begin{lstlisting}
let mut v = vec![10, 11];
let vptr = &mut v[1]; // points *into* v
v.push(12);
println!("{}", *vptr); // compiler error
\end{lstlisting}

Syntactically, the C++ and Rust versions are very similar.
Notably, the \emph{push} method in line 3 has the following signature: \verb|pub fn push(&mut self, value: T)| \cite{rust-vector-documentation}.
While the C++ version will compile the program successfully, causing a run-time security vulnerability, the Rust compiler shows an error: "Cannot borrow \emph{v} as mutable more than once at a time."
For now, it suffices to say that the Rust compiler disallows both lines 2 and 3 to create mutable references to \emph{v} if one of the mutable references is used later (like \emph{vptr} is in line 4).
% TODO: not allowing multiple mutable references only works through lifetimes, which are unexplained
In \ref{sec:rust-references}, we will explain in more detail how the Rust borrow-checker is able to detect this problem using Rust's ownership rules.

% A quick definition of ownership: you cannot have mutability and alias at the same time.
% My own example:

% \begin{lstlisting}
% fn dangle() -> &String {
%   let s = String::from("hello world");
%   &s
% }
% \end{lstlisting}

\subsection{State of the art}
\label{sec:state-of-the-art}

% - when/in which language first introduced?
% - why slow adoption?

The concept of ownership types provides one of the solutions aiming to eliminate many of the described memory-related bugs.
Potential solutions to the aliasing problem include banning aliases altogether, clearly advertising aliases or managing and controlling their effects \cite{ownership-types-survey}.
Many different flavors of ownership types have been explored.
In this paper, state of the art implementations of the ownership types concept, such as owners-as-dominators, owners-as-modifiers and owners-as-ombudsmen, will be explored further.
These approaches differ in what kind of, if any, aliases they allow.


% Main part (approach, evaluation, discussion, etc.)

\section{Ownership types in theory}
\label{sec:theory}

% TODO: second source to provide more detail of each owners-as-...
% TODO: maybe add numbered list (like in source material) for the rules like in the Rust section
If not otherwise indicated, all of the information gathered in this chapter stems from the Ownership Types Survey \cite{ownership-types-survey}.


\subsection{Domain specific terms}
\label{sec:domain-specific-terms}

In the following, some terms from the Ownership Types Survey \cite{ownership-types-survey}, which are commonly used throughout this paper, are defined.

The core concept of ownership types is that objects can be \emph{owners} of other objects.
Given objects \emph{a} and \emph{b}, \emph{a} is \emph{inside} \emph{b} if \emph{a} is the same object as \emph{b} or \emph{a} is \emph{owned} by \emph{b}, transitively.
The \emph{outside} relation is the converse of the \emph{inside} relation.

In most ownership-type variants, the heap is divided into different regions called ownership contexts.
Each object has one single ownership context, which is the set of all objects it owns.
Objects that are in the same ownership context are called \emph{siblings} or \emph{peers}.


\subsection{Owners-as-dominators}
\label{sec:owners-as-dominators}

One such flavor is the \emph{owners-as-dominators} model \cite{ownership-types-survey}, which is an implementation of the original Flexible Alias Protection concept \cite{flexible-alias-protection}, which described a core encapsulation mechanism.

Yang Zhao and John Boyland \cite{permission-ownership-types} specify that, with owners-as-dominators, each regular object must have another object or a special global "world" as its owner.
Additionally, each object can own zero or more objects.
Therefore, the ownership relation between multiple objects must be acyclic, meaning that there may be no circles in a graph where the nodes represent objects and the vertices represent the "owns" relation.
Hence, the ownership relation forms an ownership hierarchy tree, where the root is the "world" and each object is inside its owner.
Through this object encapsulation, any external reference to an object is only possible through its owner.
This model gets its name from the fact that any object acting as an owner is considered to be a \emph{dominator} for all of the owned objects.

% The rules that must be fulfilled for \emph{a} to validly reference \emph{b} are that either \emph{a} is owned by \emph{b}, \emph{a} and \emph{b} are siblings or \emph{b} is outside \emph{a}.
The survey \cite{ownership-types-survey} defines that at least one of the following rules must apply for object \emph{a} to validly reference \emph{b}.
\begin{enumerate}
  \item \emph{a} is the owner of \emph{b},
  \item \emph{a} and \emph{b} are siblings, or
  \item \emph{b} is outside of \emph{a}.
\end{enumerate}

The owners-as-dominators principle provides a simple, clear and strong guarantee but makes programming more difficult by not allowing common idioms through aliasing.


\subsection{Owners-as-modifiers}
\label{sec:owners-as-modifiers}

Another kind is the \emph{owners-as-modifiers} model \cite{ownership-types-survey}, which is a weaker form of owners-as-dominators that additionally allows read-only references.
A read-only reference can only be used to read files and call pure methods, which may not modify any existing objects.
In essence, aliasing is unrestricted, but only the owner of an object can modify it.
Owners-as-modifiers extend the rules specified for owners-as-dominators.

% For \emph{a} to validly reference \emph{b} through reference \emph{r}, owners-as-modifiers follows the same rules as owners-as-dominators.
% The only addition is that \emph{r} can also be a valid reference if it is a read-only reference and only pure methods are being called on it.
For \emph{a} to validly reference \emph{b} through reference \emph{r}, owners-as-modifiers follows the following rules \cite{ownership-types-survey}.
\begin{enumerate}
  \item \emph{a} is the owner of \emph{b},
  \item \emph{a} and \emph{b} are siblings, or
  \item \emph{b} is outside of \emph{a}, or
  \item \emph{r} is a read-only reference and only pure methods can be called on it.
\end{enumerate}

According to Werner Dietl and Peter Müller \cite{lightweight-ownership}, a fundamental difference between owners-as-dominator and owners-as-modifiers is that the former restricts \emph{where} references are allowed to point to, while the latter allows references to point to objects in arbitrary contexts, but restricts \emph{how} references can be used.

The owners-as-modifiers principle expands the programming possibilities of the owners-as-modifiers principle and fulfills the requirements needed for the verification of the functional correctness of object-oriented programs.


\subsection{Owners-as-ombudsmen}
\label{sec:owners-as-ombudsmen}

% TODO: is it obvious that this contains exact sentences from citation?
The paper that first introduced the idea of \emph{owners-as-ombudsmen} \cite{owners-as-ombudsmen} describes the concept as an extension of the owners-as-dominators model.
With owners-as-dominators, every path from the root to an object must pass through its owner.
Thus, encapsulated objects must have a single \emph{bridge object} that mediates all external interaction with its internal objects.
The owners-as-ombudsmen approach, on the other hand, relaxes the single bridge object constraint and allows several bridge objects to collectively define an aggregate with a shared representation.
These bridge objects are called \emph{ombudsmen} to emphasize their benevolent nature.

% The last flavor of ownership types is the owners-as-ombudsmen approach \cite{ownership-types-survey}, which allows idioms that do not adhere to the strong topological structure of a tree structure to be implemented.
% This is achieved by allowing multiple objects to define a shared aggregate owner.

% Extending the rules stated for owners-as-dominators, \emph{a} can also validly reference \emph{b} if \emph{a} is owned by aggregate owner \emph{b}.
For \emph{a} to validly reference \emph{b} through reference \emph{r}, owners-as-ombudsmen must adhere to at least one of the following rules \cite{ownership-types-survey}.
\begin{enumerate}
  \item \emph{a} is the owner of \emph{b},
  \item \emph{a} and \emph{b} are siblings, or
  \item \emph{b} is outside of \emph{a}, or
  \item \emph{a} is owned by aggregate owner \emph{b}
\end{enumerate}


\subsection{Advantages and disadvantages}


% \paragraph{Ownership transfer}

% TODO: possibly to do


% \subsection{Application of Ownership Types}

% TODO: chapter 6 of ownership-types-survey


\section{Implementation in Rust}
\label{sec:implementation-in-rust}

% TODO: move these links to ownership theory to individual section of Rust explanation
The modern programming language Rust uses an extended version of the ownership type model \emph{owners-as-modifiers}.
As will be discussed in this chapter, Rust allows both read-only and mutable references in a controlled manner.

All of the information gathered in this chapter is derived from the "Understanding Ownership" section from the Rust Book \cite{rust-book}.
If anything was retrieved from other sources, it would be cited as such.

\subsection{How Rust implements ownership types}
\label{sec:rust-ownership-types}

% The modern programming language Rust uses an extended version of the ownership type model \emph{owners-as-modifiers}.
% In addition to read-only references, which are allowed in owners-as-modifiers, Rust also supports mutable references in a controlled manner.

% TODO: discuss why rust allows mutable: more useful, but why?


% TODO: compare implementation of ownership types to other languages
% It is not trivial to compare the implementation of the ownership concept of Rust with that of another programming language because Rust is kind of the only one doing so.


\subsection{Memory allocation system}
\label{sec:memory-allocation}

There are two major requirements that a memory allocation system must fulfill:
At runtime, memory can be requested from the memory allocator, and there exists a mechanism for memory to be freed by the memory allocator.

The first requirement is trivial.

% TODO: find source for both garbage collection and manual freeing
One possible implementation of the second requirement is using a garbage collector, which keeps track of and cleans up memory that is no longer used.
% TODO: find source for GC disadvantages
This, however, has a runtime performance overhead and can lead to a non-deterministic cleanup of resources.

% TODO: find source for manual free disadvantages
Another more traditional solution is requiring memory to be freed explicitly.
This is a notorious source of bugs.
If memory is never freed because it was forgotten, memory is wasted.
If it is freed multiple times or accessed again after having been freed, it will result in undefined behavior.

The ideal solution pairs one \emph{allocate} with exactly one \emph{free}.
Rust uses neither a garbage collector nor requires memory to be freed manually.
Instead, the concept of ownership is leveraged to determine when to free memory.

The Rust Book \cite{rust-book} defines ownership as a set of rules that govern how it manages memory.
The compiler checks whether these rules are adhered to and does not compile the program if they are violated.
The ownership rules in Rust are as follows:
\begin{enumerate}
  \item Each value in Rust has an owner.
  \item There can only be one owner at a time.
  \item When the owner goes out of scope, the value will be \emph{dropped}.
\end{enumerate}
The scope of a value is the range within a program in which it is valid.
Rust automatically calls the function \emph{drop} when a value goes out of scope, which frees the associated memory.

The following describes how the concept of ownership is implemented in Rust.

% TODO: wording of value and types used interchangedly here, maybe incorrect
% TODO: maybe add defintion of ownership transfer if not obvious
% TODO: go into detail on how heap types are stored on heap. some constant fields are actually stored on stack (string: pointer, size, capacity)
\subsection{Transferring ownership}
\label{sec:rust-transferring-ownership}

First, one must differentiate between values that are stored on the stack and those stored on the heap.
In Rust, primitive data types (e.g. signed 32-bit integers \emph{i32}) are stored on the stack since their sizes are small and known at compile time.
In contrast, values are stored on the heap if their size is dynamic and, therefore, unknown at compile time.
The ownership concepts in Rust mainly apply to values stored on the heap.

\paragraph{Heap-based variables}

In addition to the memory safety that ownership types provide, ownership transfers can also reduce redundant copy operations.
Since heap-based values could be arbitrarily large at runtime, copying the whole value instead of transferring ownership could be very inefficient.
There are several different scenarios in which ownership is transferred.

In the simplest scenario, ownership is transferred from the variable \emph{a} to the variable \emph{b} when \emph{b} is assigned to \emph{a}.
\footnote{In some code snippets, the main function is omitted for the sake of simplicity}

\begin{lstlisting}
let a = HeapBasedType::default();
let b = a;
\end{lstlisting}
In Rust terminology, \emph{a} is \emph{moved} into \emph{b}.
After the move, \emph{a} is no longer valid, and \emph{b} is the new owner of the value.

Heap-based values will always be generated by a function at runtime.
Therefore, one can generalize the above scenario to ownership being transferred from the variable \emph{a} to the variable \emph{b} when \emph{b} is assigned to the return value \emph{a} of \emph{foo}.
\begin{lstlisting}
fn main() {
  let b = foo();
}
fn foo() {
  let a = HeapBasedType::default();
  a
}
\end{lstlisting}

Lastly, ownership is transferred from the variable \emph{a} to the variable \emph{b} when \emph{a} is passed to function \emph{foo}, which takes a parameter \emph{b}.
\begin{lstlisting}
fn main() {
  let a = HeapBasedType::default();
  foo(a);
}
fn foo(b: HeapBasedType) {
  // do something with b
}
\end{lstlisting}
In \emph{foo}, \emph{b} is the owner of the value until it is \emph{dropped} at the end of the function.
Accessing the previous owner of a value after the ownership of that value has been transferred elsewhere will lead to a compile-time error.
In this case, trying to access \emph{a} after line 3 would not compile, as \emph{a} is no longer the owner of the value.

The heap-allocated \emph{String} type in Rust provides a good example demonstrating ownership transfer of heap-based values.
\begin{lstlisting}
let x: String = String::from("hello world");
let y: String = x;
println!("x: {}, y: {}", x, y);
\end{lstlisting}
After \emph{x} is moved into \emph{y} in line 2, \emph{x} is no longer valid.
Therefore, Rust prevents you from accessing the invalid \emph{x} in the third line, and the program will not compile.


\paragraph{Stack-based values}

In contrast to heap-based values, the size of stack-based values is known at compile time and is usually small.
Therefore, stack-based values in Rust are \emph{copied} instead of \emph{moved}.
Internally, this works because primitive types are annotated with and implement the \emph{Copy} trait.

Besides the heap-allocated \emph{String} type, Rust also supports string literals \emph{\&str}, which are stored on the stack.

The following piece of code \cite{rust-book}, which is similar to the code from above but replaces the \emph{String} type with string literals, demonstrates how stack-based string literals are \emph{copied} instead of \emph{moved} into other variables in Rust.
\begin{lstlisting}
let x: &str = "hello world";
let y: &str = x;
println!("x: {}, y: {}", x, y);
\end{lstlisting}
The value of \emph{x} is copied into \emph{y}, after which both variables are still valid.
Therefore, the program compiles and "x: hello world, y: hello world" is printed to stdout.


\subsection{The Clone trait}
\label{sec:rust-clone-trait}

By default and by design, Rust will never automatically create deep copies of data stored on the heap.
To do so, one must explicitly call the \emph{clone} method on an object.

The following adjustment to the code snippet from above creates a deep copy of \emph{x} and compiles successfully.
\begin{lstlisting}
let x: String = String::from("hello world");
let y: String = x.clone();
println!("x: {}, y: {}", x, y);
\end{lstlisting}


\subsection{Immutability}
\label{sec:rust-immutability}

By default, all values and references in Rust are immutable.
An object is defined as immutable if its state cannot be modified after its creation.
In Rust, mutable values and references must be explicitly created using the \emph{mut} keyword.

For example, a string literal can be appended to a mutable String.
\begin{lstlisting}
let mut s = String::from("hello");
s.push_str("hello");
\end{lstlisting}


\subsection{References and borrowing}
\label{sec:rust-references}

Object aliasing has already been defined as the concept of accessing the same memory through different symbolic names.
Specifically, the \emph{owners-as-modifiers} approach relies on implementing the aliasing concept.
Therefore, any programming language based on this form of ownership type must provide a way of achieving this behavior.
One way to implement this behavior is by allowing the use of \emph{pointers}, which are commonly used in low-level programming languages.
However, even though they exist, "working with raw pointers in Rust is uncommon [and] typically limited to a few patterns" \cite{rust-pointer-documentation}.
% Instead, Rust primarily uses \emph{references} as the preferred way of implementing aliasing.
Instead, Rust uses \emph{references} as the preferred way of implementing aliasing.

In Rust, a \emph{reference} is an address that points to a value that is owned by another variable.
Unlike traditional \emph{pointers}, a reference is guaranteed by the compiler to point to a valid value.
In Rust terminology, creating a reference is called \emph{borrowing}.
A reference does not own the value it points to.
Therefore, only the reference itself, not the value that the reference has borrowed, is dropped at the end of the reference's scope.
Borrowing is useful for performing an operation on a value without taking ownership of it.

Rust supports creating both immutable and mutable references.
The scope of a reference starts where it is introduced and extends until the last time it is used.

\paragraph{Immutable references}

Immutable references can be seen as read-only references and are acquired using the \emph{\&} operator.
The value that immutable references refer to may not be modified.
Otherwise the program will not compile.

\begin{lstlisting}
fn main() {
  let s = String::from("hello");
  let r1 = &s;
  let r2 = &s;
  print_str(r1);
  print_str(r2);
}
fn print_str(s: &String) {
  println!("printed from a reference: {}", s);
}
\end{lstlisting}

The program will compile as long as the value \emph{s} is not modified in the \emph{print\_str} function.
Furthermore, an unlimited amount of immutable references to the same value may exist at any time.
The scopes of each of these immutable references may overlap.
However, mutable references provide an exception to this rule, which is explained in the next section.

Multiple immutable references are allowed because none of the references can modify the value.
Thereby, no immutable reference can affect another reference's reading of the value.


\paragraph{Mutable references}

Rust also supports mutable references, which are created with the \emph{&mut} keyword and allow the borrowed value to be modified.
For obvious reasons, creating a mutable reference is only possible if the borrowed value is also mutable.

\begin{lstlisting}
fn main() {
  let mut s = String::from("hello");
  modify_str(&mut s);
}
fn modify_str(s: &mut String) {
  s.push_str(" world");
}
\end{lstlisting}

The scope of a mutable reference to a value may not overlap with the scope of any other immutable or mutable reference to that same value.
This implies that there may only exist one mutable reference to a value at any given time.
During this time, no further immutable or mutable references are allowed.

This restriction exists to identify and prevent \emph{data races}, which can cause undefined behavior at compile time.
A data race occurs when two or more pointers access the same data simultaneously, at least one of the points is being used to write the data, and there exists no mechanism to synchronize access to the data \cite{rust-book}.

However, the following code example \cite{rust-book} shows that it is important to note that the creation of multiple mutable and immutable references with scopes that do not overlap is allowed.

\begin{lstlisting}
let mut s = String::from("hello");

let r1 = &s; // allowed
let r2 = &s; // allowed
println!("{} and {}", r1, r2);

let r3 = &mut s; // allowed
r3.push_str(" world");
println!("{}", r3);
\end{lstlisting}

Since \emph{r1} and \emph{r2} are not used after line 5, that is where their scopes end.
The scope of the mutable reference \emph{r3} only starts in line 7.
Therefore, the scopes of the mutable reference and the two immutable references do not overlap, and the program compiles.


\paragraph{Limits of the ownership approach}

% TODO: explain how rust uses unsafe code to implement std library
% discuss limitations of ownership types: any structures that need raw pointers? how can one deal with them?

% Rust's std lib is largely implemented using unsafe code (that doesn't strictly follow the ownership rules) for performance reasons (I think, maybe there are also other reasons).
% If the ownership semantics are no longer used to prove the correctness of a program, how is the safety of the std lib guaranteed?
% Is it guaranteed at all.
% If not, a compelling argument for ownership types with an unsafe implementation is still, that the programmers rarely/never have to use the unsafe code, and will make less mistakes.
% The API of the stdlib is safe, the implementation isn't.


% \paragraph{Lifetimes}

% TODO: explain how dangling references are prevented



% \section{Practical examples using Rust}
% - show common Rust ownership errors
% - Protection against memory vulnerabilitie examples
% - reference: \cite{rust-by-example}


% \section{Alternatives}
% - comparison to alternative type systems without ownership (C/C++: none at all, Java: garbage collection)
% - choose non-ownership programming language e.g. C++20
% - compare code examples
% - compile time differences between Rust and non-ownership lang
% - runtime differences between Rust and non-ownership lang


\section{Summary \& Outlook}
\label{sec:summary}

In summary, programming languages based on ownership types can eliminate many memory-related issues by enforcing strict rules on the existence and behavior of references to values.
Furthermore, an enhanced version of the ownership types concept is integral to the Rust programming language.
Compared to more commonly used low-level programming languages like C, Rust introduces many memory-related rules that are strictly enforced by the compiler at compile time, allowing for strong runtime performance and omitting the need for many manual, rigorous and error-prone memory reference checks that programmers used to have to perform.
Even though the Rust compiler forces developers to think more intentionally about how they deal with memory through ownership, they will receive helpful compile-time error messages instead of crashes or undefined behavior at runtime if they do something wrong.

It will be interesting to see how Rust's development will continue in the future.
Given its rise in popularity as a safe and performant programming language using strict ownership types, the question arises of whether ownership types might also be incorporated into more new or existing programming languages in the future.


\bibliographystyle{ACM-Reference-Format}
\bibliography{paper} % read paper.bib file

\end{document}
