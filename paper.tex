\documentclass[sigplan,11pt,nonacm]{acmart}
\settopmatter{printfolios}

\usepackage{booktabs} % For formal tables
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{hyphenat}
\usepackage{todonotes}
\usepackage[babel]{csquotes}
\usepackage{listings}
\lstset{frame=tb,
  language=Rust,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\begin{document}
\title{Ownership types in theory and practice (in Rust)}
\author{Fritz Rehde}
\affiliation{%
  \institution{Technical University of Munich}
}
\email{fritz.rehde@tum.de}

\begin{abstract}
% Abstract: Brief summary of area, problem, approach, key result

% - why do we need ownership types, what do they do?

Object aliasing is the concept of accessing the same memory through different symbolic names in object-oriented programming languages.
Many progamming bugs are created through unintentional aliases, which are hard to detect and can lead to unexpected side-effects.
Ownership types are one solution that attempt to prevent many alias-related bugs.
The premise of ownership types is that not only the fields of an object are protected from external access, but also all objects stored in those fields.
This is done by allowing objects to take ownership of other objects.
% TODO: add citation\cite{ownership-types-survey}

This paper depicts the different kinds of ownership types and explains how the modern programming language Rust uses ownership types to garantue memory safety.

\end{abstract}

\keywords{Ownership, Type, Safety, Rust}

\maketitle

\section{Introduction}
\label{sec:introduction}
% Introduction: introduce area, problem, approach, key results, contributions, outline

% TODO: write something

\section{Background}
\label{sec:background}
% Background: if needed, describe prerequisites

One of the main goals of ownership types is to improve memory safety.
Understanding memory-related bugs will, therefore, help in understanding why ownership types are useful.

\subsection{Memory Safety}

% source: Definition of memory safety\cite{memory1}.
% source: Why memory safery is important\cite{nsa-memory-safety}.

Memory safety is defined as ...

\subsection{Domain specific terms}

In the following, some terms that commonly used throughout this paper are explained.
The core concept of ownership types is that objects can be \emph{owners} of other objects.
Given objects \emph{a} and \emph{b}, \emph{a} is \emph{inside} \emph{b} if \emph{a} is the same object as \emph{b} or \emph{a} is owned by \emph{b}, transitively.
The \emph{outside} relation is the converse of the \emph{inside} relation.

In most ownership types variants, the heap is divided into different regions called ownership contexts.
Each object has one single ownership context, which is the set of all objects it owns.
Objects that are in the same ownership context are called \emph{siblings} or \emph{peers}.
\cite{ownership-types-survey}

\subsection{State of the art}

% - when/in which language first introduced?
% - why slow adoption?


Potential solutions to the aliasing problem include banning aliases altogether, clearly advertising aliases or managing and controlling its effects\cite{ownership-types-survey}.
Many different flavours of ownership types have been explored.
In this paper, state of the art implementations of the ownership type concept such as owners-as-dominators, owners-as-modifiers and owners-as-ombudsmen will be explored further.
These approaches differ in how what kind of, if any, aliases they allow.
\cite{ownership-types-survey}


\section{Main part}
\label{sec:mainpart}
% Main part (approach, evaluation, discussion, etc.)

\subsection{Ownership types in theory}


% TODO: second source to provide more detail of each owners-as-...
% TODO: find more varied words to classify these approaches as: principle, approach, model
% TODO: maybe add numbered list (like in source material) for the rules like in the Rust section

\subsubsection{Owners-as-dominators}

One such flavour is the owners-as-dominators\cite{ownership-types-survey} invariant, where the heap is structured as a tree with each object being inside its owner.
External access is therefore only possible through the owner.
The rules that must be fulfilled for \emph{a} to validly reference \emph{b} are that either \emph{a} is owned by \emph{b}, \emph{a} and \emph{b} are siblings or \emph{b} is outside \emph{a}.
% TODO: more detail

The owners-as-dominators principle provides a simple, clear and strong guarantee, but makes programming more difficult by not allowing common idioms through aliasing.
\cite{ownership-types-survey}


\subsubsection{Owners-as-modifiers}

Another kind is the owners-as-modifiers model, which is a weaker form of owners-as-dominators that additionally allows read-only references.
A read-only reference can only be used to read files and call pure methods, which may not modify any existing objects.
In essence, aliasing is unrestricted, but only the owner of an object can modify it.
% TODO: unclear sentence structure
Owners-as-modifiers extend the rules specified for owners-as-dominators.
For \emph{a} to validly reference \emph{b} through reference \emph{r}, onwers-as-modifiers follows the same rules as owners-as-dominators.
The only addition is that, if none of the owners-as-dominators rules are upheld, \emph{r} can also be valid by being a read-only reference and only pure methods being called on it.
% TODO: more detail

The owners-as-modifiers principle expands the programming possibilities of the owners-as-modifiers principle and fulfills the requirements of verification of object-oriented programs.

\cite{ownership-types-survey}


\subsubsection{Owners-as-ombudsmen}

% TODO: definition of ombudsmen for context
A last flavour of ownership types is the owners-as-ombudsmen approach, which allows idioms that do not adhere to the strong topological structure of a tree structure to be implemented.
% TODO: examples
This is achieved by allowing multiple objects to define a shared aggregate owner.
% TODO: what is aggregate owner
Extending the rules stated for owners-as-dominators, \emph{a} can also validly reference \emph{b} if \emph{a} is owned by aggregate owner \emph{b}.

\cite{ownership-types-survey}

\subsection{Implementation in Rust}

There are two major requirements that a memory allocation system must fulfill:
At runtime, memory can be requested from the memory allocator and there exists a mechanism for memory to be freed by the memory allocator.

The first requirement is trivial.

% TODO: find source for both garbage collection and manual freeing
One possible implementation of the second requirement is using a garbage collector, which keeps track of and cleans up memory that is no longer used.
% TODO: find source for GC disadvantages
This, however, has a runtime performance overhead and can lead to a non-deterministic cleanup of resources.

% TODO: find source for manual free disadvantages
Another more traditional solution is requiring memory to be freed explicitly.
This is a notorious source of bugs.
If memory is never freed because it was forgotten, memory is wasted.
If it is freed multiple times or accessed again after having been freed, it will result in undefined behaviour.

The ideal solution pairs one \emph{allocate} with exactly one \emph{free}.
Rust uses neither a garbage collector nor requires memory to be freed manually.
Instead, the concept of ownership is leveraged to determine when to free memory.

The Rust book \cite{rust-book} defines ownership as a set of rules that govern how it manages memory.
The compiler checks whether these rules are adhered to, and does not compile the program if they are violated.
The ownership rules in Rust are as follows:
\begin{enumerate}
  \item Each value in Rust has an owner.
  \item There can only be one owner at a time.
  \item When the owner goes out of scope, the value will be \emph{dropped}.
\end{enumerate}
% Rust automatically calls the function \emph{drop} when a variable goes out of scope, which frees the memory of the value that is owned by that variable.
% TODO: is a variable really an owner of a value? Possibly change term variable
The scope of a value is the range within a program in which it is valid.
Rust automatically calls the function \emph{drop}, which frees the associated memory, when a variable goes out of scope.

The following describes the concepts of how variables and memory interact in Rust.
\cite{rust-book}

\subsubsection{Move}

% TODO: wording of value and types used interchangedly here, maybe incorrect
% First, one must differentiate between values that are stored on the stack and those stored on the heap.
In Rust, primitive data types (e.g. signed 32 bit integers \emph{i32}) are immutable by default and stored on the stack, since their sizes are small and known at compile time.
Values are stored on the heap if their size is dynamic and therefore not known at compile time.

% TODO: a good example of what?
The different representations of strings in Rust provide a good example.
Rust supports immutable string literals \emph{\&str}, which are stored on the stack, and objects of type \emph{String}, which are stored as a vector of bytes on the heap and are, therefore, growable. \cite{rust-by-example}

% TODO: footnote that main class etc. have been omitted for sake of simplicity
The following piece of code demonstrates how primitive values are \emph{moved} into other variables in Rust.
\begin{lstlisting}
let x: &str = "hello world";
let y: &str = x;
println!("x: {}, y: {}", x, y);
\end{lstlisting}
Since \emph{x} has a known, fixed size, its value is simply copied into \emph{y}.
Therefore, the program compiles and, as expected, "x: hello world, y: hello world" is printed to stdout.
% TODO: explain what Rust traits are
Internally, these primitive types are annotated with the \emph{Copy} trait, which specifies that 

However, a similar code snippet that replaces the string literal with the \emph{String} type behaves differently.
\begin{lstlisting}
let x: String = String::from("hello world");
let y: String = x;
println!("x: {}, y: {}", x, y);
\end{lstlisting}
% TODO: go into detail on how strings are stored on heap.
The \emph{String} value stored in \emph{x} could be arbitrarily long at runtime.
Thus, copying the whole string into \emph{y} could be very inefficient.
% TODO: avoid and at beginning of sentence
And, since the \emph{String} value can only have one owner, it is \emph{moved} into \emph{y}, which will become its new owner.
After the move, \emph{x} is no longer valid.
Because Rust prevents you from using the invalid reference to \emph{x} in the third line, the program will not compile.

% TODO: add section explaing borrowing, since it's related ot move


\subsubsection{Clone}

By default and by design, Rust will never automatically create deep copies of data stored on the heap.
To do so, one must explicitly call the \emph{clone} method on an object.

The following adjustement to the code snippet from above creates a deep copy of \emph{x} and compiles successfully.
\begin{lstlisting}
let x: String = String::from("hello world");
let y: String = x.clone();
println!("x: {}, y: {}", x, y);
\end{lstlisting}

\cite{rust-book}


\subsection{Practical examples using Rust}
% - show common Rust ownership errors
% - Protection against memory vulnerabilitie examples
% - reference: \cite{rust-by-example}


\subsection{Alternatives}
% - comparison to alternative type systems without ownership (C/C++: none at all, Java: garbage collection)
% - choose non-ownership programming language e.g. C++20
% - compare code examples
% - compile time differences between Rust and non-ownership lang
% - runtime differences between Rust and non-ownership lang


\section{Related work}
\label{sec:relatedwork}
% (In a paper: Related Work – might come before main part)


\section{Summary \& Outlook}
\label{sec:summary}



\bibliographystyle{ACM-Reference-Format}
\bibliography{paper} % read paper.bib file

\end{document}
